//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import {catchError as _observableCatch, mergeMap as _observableMergeMap} from 'rxjs/operators';
import {Observable, of as _observableOf, throwError as _observableThrow} from 'rxjs';
import {Inject, Injectable, InjectionToken, Optional} from '@angular/core';
import {HttpClient, HttpHeaders, HttpResponse, HttpResponseBase} from '@angular/common/http';

export module ChangeBlogApi {
  export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

  @Injectable()
  export class Client {
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;
    private http: HttpClient;
    private baseUrl: string;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
      this.http = http;
      this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    getApiInfo(): Observable<ApiInfo> {
      let url_ = this.baseUrl + "/api/info";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetApiInfo(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetApiInfo(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<ApiInfo>;
          }
        } else
          return _observableThrow(response_) as any as Observable<ApiInfo>;
      }));
    }

    /**
     * @param searchTerm (optional)
     * @param lastVersionId (optional)
     * @param limit (optional)
     * @return Success
     */
    getApiChangeLogs(searchTerm?: string | undefined, lastVersionId?: string | undefined, limit?: number | undefined): Observable<VersionDto[]> {
      let url_ = this.baseUrl + "/api/changes?";
      if (searchTerm === null)
        throw new Error("The parameter 'searchTerm' cannot be null.");
      else if (searchTerm !== undefined)
        url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
      if (lastVersionId === null)
        throw new Error("The parameter 'lastVersionId' cannot be null.");
      else if (lastVersionId !== undefined)
        url_ += "lastVersionId=" + encodeURIComponent("" + lastVersionId) + "&";
      if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
      else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetApiChangeLogs(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetApiChangeLogs(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<VersionDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<VersionDto[]>;
      }));
    }

    /**
     * @return Success
     */
    getAccounts(): Observable<AccountDto[]> {
      let url_ = this.baseUrl + "/api/v1/accounts";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetAccounts(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAccounts(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<AccountDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<AccountDto[]>;
      }));
    }

    /**
     * @return Success
     */
    getAccount(accountId: string): Observable<AccountDto> {
      let url_ = this.baseUrl + "/api/v1/accounts/{accountId}";
      if (accountId === undefined || accountId === null)
        throw new Error("The parameter 'accountId' must be defined.");
      url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetAccount(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAccount(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<AccountDto>;
          }
        } else
          return _observableThrow(response_) as any as Observable<AccountDto>;
      }));
    }

    /**
     * @param lastUserId (optional)
     * @param limit (optional)
     * @return Success
     */
    getAccountUsers(accountId: string, lastUserId?: string | undefined, limit?: number | undefined): Observable<UserDto[]> {
      let url_ = this.baseUrl + "/api/v1/accounts/{accountId}/users?";
      if (accountId === undefined || accountId === null)
        throw new Error("The parameter 'accountId' must be defined.");
      url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
      if (lastUserId === null)
        throw new Error("The parameter 'lastUserId' cannot be null.");
      else if (lastUserId !== undefined)
        url_ += "lastUserId=" + encodeURIComponent("" + lastUserId) + "&";
      if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
      else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetAccountUsers(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAccountUsers(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<UserDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<UserDto[]>;
      }));
    }

    /**
     * @param lastProductId (optional)
     * @param limit (optional)
     * @param includeClosed (optional)
     * @return Success
     */
    getAccountProducts(accountId: string, lastProductId?: string | undefined, limit?: number | undefined, includeClosed?: boolean | undefined): Observable<ProductDto[]> {
      let url_ = this.baseUrl + "/api/v1/accounts/{accountId}/products?";
      if (accountId === undefined || accountId === null)
        throw new Error("The parameter 'accountId' must be defined.");
      url_ = url_.replace("{accountId}", encodeURIComponent("" + accountId));
      if (lastProductId === null)
        throw new Error("The parameter 'lastProductId' cannot be null.");
      else if (lastProductId !== undefined)
        url_ += "lastProductId=" + encodeURIComponent("" + lastProductId) + "&";
      if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
      else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
      if (includeClosed === null)
        throw new Error("The parameter 'includeClosed' cannot be null.");
      else if (includeClosed !== undefined)
        url_ += "includeClosed=" + encodeURIComponent("" + includeClosed) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetAccountProducts(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetAccountProducts(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<ProductDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<ProductDto[]>;
      }));
    }

    /**
     * @param filter (optional)
     * @param includePermissions (optional)
     * @return Success
     */
    getRoles(filter?: string | undefined, includePermissions?: boolean | undefined): Observable<RoleDto[]> {
      let url_ = this.baseUrl + "/api/v1/accounts/roles?";
      if (filter === null)
        throw new Error("The parameter 'filter' cannot be null.");
      else if (filter !== undefined)
        url_ += "filter=" + encodeURIComponent("" + filter) + "&";
      if (includePermissions === null)
        throw new Error("The parameter 'includePermissions' cannot be null.");
      else if (includePermissions !== undefined)
        url_ += "includePermissions=" + encodeURIComponent("" + includePermissions) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetRoles(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetRoles(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<RoleDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<RoleDto[]>;
      }));
    }

    /**
     * @param lastProductId (optional)
     * @param limit (optional)
     * @param includeClosed (optional)
     * @return Success
     */
    getUserProducts(lastProductId?: string | undefined, limit?: number | undefined, includeClosed?: boolean | undefined): Observable<ProductDto[]> {
      let url_ = this.baseUrl + "/api/v1/user/products?";
      if (lastProductId === null)
        throw new Error("The parameter 'lastProductId' cannot be null.");
      else if (lastProductId !== undefined)
        url_ += "lastProductId=" + encodeURIComponent("" + lastProductId) + "&";
      if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
      else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
      if (includeClosed === null)
        throw new Error("The parameter 'includeClosed' cannot be null.");
      else if (includeClosed !== undefined)
        url_ += "includeClosed=" + encodeURIComponent("" + includeClosed) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetUserProducts(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetUserProducts(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<ProductDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<ProductDto[]>;
      }));
    }

    /**
     * @return Success
     */
    getProduct(productId: string): Observable<ProductDto> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetProduct(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProduct(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<ProductDto>;
          }
        } else
          return _observableThrow(response_) as any as Observable<ProductDto>;
      }));
    }

    /**
     * @param body (optional)
     * @return Created
     */
    addProduct(body?: AddOrUpdateProductDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/products";
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAddProduct(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddProduct(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    closeProduct(productId: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/close";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processCloseProduct(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processCloseProduct(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    getVersion(versionId: string): Observable<VersionDto> {
      let url_ = this.baseUrl + "/api/v1/versions/{versionId}";
      if (versionId === undefined || versionId === null)
        throw new Error("The parameter 'versionId' must be defined.");
      url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetVersion(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetVersion(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<VersionDto>;
          }
        } else
          return _observableThrow(response_) as any as Observable<VersionDto>;
      }));
    }

    /**
     * @return Success
     */
    deleteVersion(versionId: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/versions/{versionId}";
      if (versionId === undefined || versionId === null)
        throw new Error("The parameter 'versionId' must be defined.");
      url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDeleteVersion(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDeleteVersion(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @param searchTerm (optional)
     * @param lastVersionId (optional)
     * @param includeDeleted (optional)
     * @param limit (optional)
     * @return Success
     */
    gerVersions(productId: string, searchTerm?: string | undefined, lastVersionId?: string | undefined, includeDeleted?: boolean | undefined, limit?: number | undefined): Observable<VersionDto[]> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/versions?";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      if (searchTerm === null)
        throw new Error("The parameter 'searchTerm' cannot be null.");
      else if (searchTerm !== undefined)
        url_ += "searchTerm=" + encodeURIComponent("" + searchTerm) + "&";
      if (lastVersionId === null)
        throw new Error("The parameter 'lastVersionId' cannot be null.");
      else if (lastVersionId !== undefined)
        url_ += "lastVersionId=" + encodeURIComponent("" + lastVersionId) + "&";
      if (includeDeleted === null)
        throw new Error("The parameter 'includeDeleted' cannot be null.");
      else if (includeDeleted !== undefined)
        url_ += "includeDeleted=" + encodeURIComponent("" + includeDeleted) + "&";
      if (limit === null)
        throw new Error("The parameter 'limit' cannot be null.");
      else if (limit !== undefined)
        url_ += "limit=" + encodeURIComponent("" + limit) + "&";
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGerVersions(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGerVersions(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<VersionDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<VersionDto[]>;
      }));
    }

    /**
     * @param body (optional)
     * @return Created
     */
    addVersion(productId: string, body?: AddVersionDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/versions";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAddVersion(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddVersion(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    getLatestVersion(productId: string): Observable<VersionDto> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/versions/latest";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetLatestVersion(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLatestVersion(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<VersionDto>;
          }
        } else
          return _observableThrow(response_) as any as Observable<VersionDto>;
      }));
    }

    /**
     * @return Success
     */
    getProductVersion(productId: string, version: string): Observable<VersionDto[]> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/versions/{version}";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      if (version === undefined || version === null)
        throw new Error("The parameter 'version' must be defined.");
      url_ = url_.replace("{version}", encodeURIComponent("" + version));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetProductVersion(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetProductVersion(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<VersionDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<VersionDto[]>;
      }));
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateVersion(productId: string, version: string, body?: AddOrUpdateVersionDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/versions/{version}";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      if (version === undefined || version === null)
        throw new Error("The parameter 'version' must be defined.");
      url_ = url_.replace("{version}", encodeURIComponent("" + version));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processUpdateVersion(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateVersion(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    releaseVersion(versionId: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/versions/{versionId}/release";
      if (versionId === undefined || versionId === null)
        throw new Error("The parameter 'versionId' must be defined.");
      url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processReleaseVersion(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processReleaseVersion(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    getPendingChangeLogs(productId: string): Observable<ChangeLogLineDto[]> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/pending-changelogs";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetPendingChangeLogs(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPendingChangeLogs(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<ChangeLogLineDto[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<ChangeLogLineDto[]>;
      }));
    }

    /**
     * @param body (optional)
     * @return Created
     */
    addPendingChangeLogLine(productId: string, body?: AddOrUpdateChangeLogLineDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/pending-changelogs";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAddPendingChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddPendingChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    deleteAllPendingChangeLogs(productId: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/pending-changelogs";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDeleteAllPendingChangeLogs(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDeleteAllPendingChangeLogs(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    getPendingChangeLogLine(changeLogLineId: string): Observable<PendingChangeLogLineDto> {
      let url_ = this.baseUrl + "/api/v1/pending-changelogs/{changeLogLineId}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetPendingChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetPendingChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<PendingChangeLogLineDto>;
          }
        } else
          return _observableThrow(response_) as any as Observable<PendingChangeLogLineDto>;
      }));
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updatePendingChangeLogLine(changeLogLineId: string, body?: PatchChangeLogLineDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/pending-changelogs/{changeLogLineId}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processUpdatePendingChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdatePendingChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    deletePendingChangeLogLine(changeLogLineId: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/pending-changelogs/{changeLogLineId}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDeletePendingChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDeletePendingChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @param body (optional)
     * @return Success
     */
    movePendingChangeLogLine(changeLogLineId: string, body?: MoveChangeLogLineDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/pending-changelogs/{changeLogLineId}/move";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processMovePendingChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMovePendingChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @param body (optional)
     * @return Success
     */
    moveAllPendingChangeLogs(productId: string, body?: MoveChangeLogLineDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/products/{productId}/pending-changelogs/move";
      if (productId === undefined || productId === null)
        throw new Error("The parameter 'productId' must be defined.");
      url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processMoveAllPendingChangeLogs(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMoveAllPendingChangeLogs(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    getChangeLogLine(changeLogLineId: string): Observable<ChangeLogLineDto> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<ChangeLogLineDto>;
          }
        } else
          return _observableThrow(response_) as any as Observable<ChangeLogLineDto>;
      }));
    }

    /**
     * @return Success
     */
    deleteChangeLogLine(changeLogLineId: string): Observable<ErrorResponse> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDeleteChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDeleteChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<ErrorResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<ErrorResponse>;
      }));
    }

    /**
     * @param body (optional)
     * @return Success
     */
    updateChangeLogLine(changeLogLineId: string, body?: PatchChangeLogLineDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processUpdateChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processUpdateChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @param body (optional)
     * @return Created
     */
    addChangeLogLine(versionId: string, body?: AddOrUpdateChangeLogLineDto | undefined): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/versions/{versionId}/changelogs";
      if (versionId === undefined || versionId === null)
        throw new Error("The parameter 'versionId' must be defined.");
      url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
      url_ = url_.replace(/[?&]$/, "");

      const content_ = JSON.stringify(body);

      let options_: any = {
        body: content_,
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Content-Type": "application/json",
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAddChangeLogLine(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddChangeLogLine(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    makeChangeLogLinePending(changeLogLineId: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}/make-pending";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processMakeChangeLogLinePending(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMakeChangeLogLinePending(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    makeAllChangeLogLinesPending(versionId: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/versions/{versionId}/changelogs/make-pending";
      if (versionId === undefined || versionId === null)
        throw new Error("The parameter 'versionId' must be defined.");
      url_ = url_.replace("{versionId}", encodeURIComponent("" + versionId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processMakeAllChangeLogLinesPending(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processMakeAllChangeLogLinesPending(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    getLabels(changeLogLineId: string): Observable<string[]> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}/labels";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetLabels(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetLabels(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<string[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<string[]>;
      }));
    }

    /**
     * @return Success
     */
    addLabel(changeLogLineId: string, label: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}/labels/{label}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      if (label === undefined || label === null)
        throw new Error("The parameter 'label' must be defined.");
      url_ = url_.replace("{label}", encodeURIComponent("" + label));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAddLabel(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddLabel(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    deleteLabel(changeLogLineId: string, label: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}/labels/{label}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      if (label === undefined || label === null)
        throw new Error("The parameter 'label' must be defined.");
      url_ = url_.replace("{label}", encodeURIComponent("" + label));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDeleteLabel(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDeleteLabel(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    getIssues(changeLogLineId: string): Observable<string[]> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}/issues";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processGetIssues(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processGetIssues(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<string[]>;
          }
        } else
          return _observableThrow(response_) as any as Observable<string[]>;
      }));
    }

    /**
     * @return Success
     */
    addIssue(changeLogLineId: string, issue: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}/issues/{issue}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      if (issue === undefined || issue === null)
        throw new Error("The parameter 'issue' must be defined.");
      url_ = url_.replace("{issue}", encodeURIComponent("" + issue));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processAddIssue(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processAddIssue(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    /**
     * @return Success
     */
    deleteIssue(changeLogLineId: string, issue: string): Observable<SuccessResponse> {
      let url_ = this.baseUrl + "/api/v1/changelogs/{changeLogLineId}/issues/{issue}";
      if (changeLogLineId === undefined || changeLogLineId === null)
        throw new Error("The parameter 'changeLogLineId' must be defined.");
      url_ = url_.replace("{changeLogLineId}", encodeURIComponent("" + changeLogLineId));
      if (issue === undefined || issue === null)
        throw new Error("The parameter 'issue' must be defined.");
      url_ = url_.replace("{issue}", encodeURIComponent("" + issue));
      url_ = url_.replace(/[?&]$/, "");

      let options_: any = {
        observe: "response",
        responseType: "blob",
        headers: new HttpHeaders({
          "Accept": "application/json"
        })
      };

      return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
        return this.processDeleteIssue(response_);
      })).pipe(_observableCatch((response_: any) => {
        if (response_ instanceof HttpResponseBase) {
          try {
            return this.processDeleteIssue(response_ as any);
          } catch (e) {
            return _observableThrow(e) as any as Observable<SuccessResponse>;
          }
        } else
          return _observableThrow(response_) as any as Observable<SuccessResponse>;
      }));
    }

    protected processGetApiInfo(response: HttpResponseBase): Observable<ApiInfo> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ApiInfo.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetApiChangeLogs(response: HttpResponseBase): Observable<VersionDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(VersionDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetAccounts(response: HttpResponseBase): Observable<AccountDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(AccountDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetAccount(response: HttpResponseBase): Observable<AccountDto> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = AccountDto.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetAccountUsers(response: HttpResponseBase): Observable<UserDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(UserDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetAccountProducts(response: HttpResponseBase): Observable<ProductDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProductDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetRoles(response: HttpResponseBase): Observable<RoleDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(RoleDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetUserProducts(response: HttpResponseBase): Observable<ProductDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ProductDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetProduct(response: HttpResponseBase): Observable<ProductDto> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ProductDto.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processAddProduct(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = SuccessResponse.fromJS(resultData201);
          return _observableOf(result201);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processCloseProduct(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetVersion(response: HttpResponseBase): Observable<VersionDto> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = VersionDto.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processDeleteVersion(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGerVersions(response: HttpResponseBase): Observable<VersionDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(VersionDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processAddVersion(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = SuccessResponse.fromJS(resultData201);
          return _observableOf(result201);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetLatestVersion(response: HttpResponseBase): Observable<VersionDto> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = VersionDto.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetProductVersion(response: HttpResponseBase): Observable<VersionDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(VersionDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processUpdateVersion(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = ErrorResponse.fromJS(resultData201);
          return throwException("Created", status, _responseText, _headers, result201);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processReleaseVersion(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetPendingChangeLogs(response: HttpResponseBase): Observable<ChangeLogLineDto[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(ChangeLogLineDto.fromJS(item));
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processAddPendingChangeLogLine(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = SuccessResponse.fromJS(resultData201);
          return _observableOf(result201);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processDeleteAllPendingChangeLogs(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetPendingChangeLogLine(response: HttpResponseBase): Observable<PendingChangeLogLineDto> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = PendingChangeLogLineDto.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processUpdatePendingChangeLogLine(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processDeletePendingChangeLogLine(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processMovePendingChangeLogLine(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processMoveAllPendingChangeLogs(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetChangeLogLine(response: HttpResponseBase): Observable<ChangeLogLineDto> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ChangeLogLineDto.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processDeleteChangeLogLine(response: HttpResponseBase): Observable<ErrorResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = ErrorResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processUpdateChangeLogLine(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processAddChangeLogLine(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 201) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result201: any = null;
          let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result201 = SuccessResponse.fromJS(resultData201);
          return _observableOf(result201);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processMakeChangeLogLinePending(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processMakeAllChangeLogLinesPending(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetLabels(response: HttpResponseBase): Observable<string[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(item);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processAddLabel(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processDeleteLabel(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processGetIssues(response: HttpResponseBase): Observable<string[]> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
              result200!.push(item);
          } else {
            result200 = <any>null;
          }
          return _observableOf(result200);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processAddIssue(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status === 422) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result422: any = null;
          let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result422 = ErrorResponse.fromJS(resultData422);
          return throwException("Client Error", status, _responseText, _headers, result422);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }

    protected processDeleteIssue(response: HttpResponseBase): Observable<SuccessResponse> {
      const status = response.status;
      const responseBlob =
        response instanceof HttpResponse ? response.body :
          (response as any).error instanceof Blob ? (response as any).error : undefined;

      let _headers: any = {};
      if (response.headers) {
        for (let key of response.headers.keys()) {
          _headers[key] = response.headers.get(key);
        }
      }
      if (status === 400) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result400: any = null;
          let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result400 = ErrorResponse.fromJS(resultData400);
          return throwException("Bad Request", status, _responseText, _headers, result400);
        }));
      } else if (status === 401) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result401: any = null;
          let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result401 = ErrorResponse.fromJS(resultData401);
          return throwException("Unauthorized", status, _responseText, _headers, result401);
        }));
      } else if (status === 403) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result403: any = null;
          let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result403 = ErrorResponse.fromJS(resultData403);
          return throwException("Forbidden", status, _responseText, _headers, result403);
        }));
      } else if (status === 200) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result200: any = null;
          let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result200 = SuccessResponse.fromJS(resultData200);
          return _observableOf(result200);
        }));
      } else if (status === 404) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result404: any = null;
          let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result404 = ErrorResponse.fromJS(resultData404);
          return throwException("Not Found", status, _responseText, _headers, result404);
        }));
      } else if (status === 409) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          let result409: any = null;
          let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
          result409 = ErrorResponse.fromJS(resultData409);
          return throwException("Conflict", status, _responseText, _headers, result409);
        }));
      } else if (status !== 200 && status !== 204) {
        return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
          return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }));
      }
      return _observableOf(null as any);
    }
  }

  export class AccountDto implements IAccountDto {
    id?: string;
    name?: string | undefined;
    defaultVersioningScheme?: string | undefined;
    defaultVersioningSchemeId?: string;
    createdAt?: Date;

    constructor(data?: IAccountDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): AccountDto {
      data = typeof data === 'object' ? data : {};
      let result = new AccountDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.name = _data["name"];
        this.defaultVersioningScheme = _data["defaultVersioningScheme"];
        this.defaultVersioningSchemeId = _data["defaultVersioningSchemeId"];
        this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["name"] = this.name;
      data["defaultVersioningScheme"] = this.defaultVersioningScheme;
      data["defaultVersioningSchemeId"] = this.defaultVersioningSchemeId;
      data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
      return data;
    }
  }

  export interface IAccountDto {
    id?: string;
    name?: string | undefined;
    defaultVersioningScheme?: string | undefined;
    defaultVersioningSchemeId?: string;
    createdAt?: Date;
  }

  export class AddOrUpdateChangeLogLineDto implements IAddOrUpdateChangeLogLineDto {
    text!: string;
    labels?: string[] | undefined;
    issues?: string[] | undefined;

    constructor(data?: IAddOrUpdateChangeLogLineDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): AddOrUpdateChangeLogLineDto {
      data = typeof data === 'object' ? data : {};
      let result = new AddOrUpdateChangeLogLineDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.text = _data["text"];
        if (Array.isArray(_data["labels"])) {
          this.labels = [] as any;
          for (let item of _data["labels"])
            this.labels!.push(item);
        }
        if (Array.isArray(_data["issues"])) {
          this.issues = [] as any;
          for (let item of _data["issues"])
            this.issues!.push(item);
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["text"] = this.text;
      if (Array.isArray(this.labels)) {
        data["labels"] = [];
        for (let item of this.labels)
          data["labels"].push(item);
      }
      if (Array.isArray(this.issues)) {
        data["issues"] = [];
        for (let item of this.issues)
          data["issues"].push(item);
      }
      return data;
    }
  }

  export interface IAddOrUpdateChangeLogLineDto {
    text: string;
    labels?: string[] | undefined;
    issues?: string[] | undefined;
  }

  export class AddOrUpdateProductDto implements IAddOrUpdateProductDto {
    name!: string;
    versioningSchemeId?: string | undefined;
    languageCode!: string;
    accountId!: string;

    constructor(data?: IAddOrUpdateProductDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): AddOrUpdateProductDto {
      data = typeof data === 'object' ? data : {};
      let result = new AddOrUpdateProductDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.name = _data["name"];
        this.versioningSchemeId = _data["versioningSchemeId"];
        this.languageCode = _data["languageCode"];
        this.accountId = _data["accountId"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["name"] = this.name;
      data["versioningSchemeId"] = this.versioningSchemeId;
      data["languageCode"] = this.languageCode;
      data["accountId"] = this.accountId;
      return data;
    }
  }

  export interface IAddOrUpdateProductDto {
    name: string;
    versioningSchemeId?: string | undefined;
    languageCode: string;
    accountId: string;
  }

  export class AddOrUpdateVersionDto implements IAddOrUpdateVersionDto {
    name?: string | undefined;
    changeLogLines!: AddOrUpdateChangeLogLineDto[];
    releaseImmediately?: boolean;

    constructor(data?: IAddOrUpdateVersionDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
      if (!data) {
        this.changeLogLines = [];
      }
    }

    static fromJS(data: any): AddOrUpdateVersionDto {
      data = typeof data === 'object' ? data : {};
      let result = new AddOrUpdateVersionDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.name = _data["name"];
        if (Array.isArray(_data["changeLogLines"])) {
          this.changeLogLines = [] as any;
          for (let item of _data["changeLogLines"])
            this.changeLogLines!.push(AddOrUpdateChangeLogLineDto.fromJS(item));
        }
        this.releaseImmediately = _data["releaseImmediately"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["name"] = this.name;
      if (Array.isArray(this.changeLogLines)) {
        data["changeLogLines"] = [];
        for (let item of this.changeLogLines)
          data["changeLogLines"].push(item.toJSON());
      }
      data["releaseImmediately"] = this.releaseImmediately;
      return data;
    }
  }

  export interface IAddOrUpdateVersionDto {
    name?: string | undefined;
    changeLogLines: AddOrUpdateChangeLogLineDto[];
    releaseImmediately?: boolean;
  }

  export class AddVersionDto implements IAddVersionDto {
    version!: string;
    name?: string | undefined;
    changeLogLines!: AddOrUpdateChangeLogLineDto[];
    releaseImmediately?: boolean;

    constructor(data?: IAddVersionDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
      if (!data) {
        this.changeLogLines = [];
      }
    }

    static fromJS(data: any): AddVersionDto {
      data = typeof data === 'object' ? data : {};
      let result = new AddVersionDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.version = _data["version"];
        this.name = _data["name"];
        if (Array.isArray(_data["changeLogLines"])) {
          this.changeLogLines = [] as any;
          for (let item of _data["changeLogLines"])
            this.changeLogLines!.push(AddOrUpdateChangeLogLineDto.fromJS(item));
        }
        this.releaseImmediately = _data["releaseImmediately"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["version"] = this.version;
      data["name"] = this.name;
      if (Array.isArray(this.changeLogLines)) {
        data["changeLogLines"] = [];
        for (let item of this.changeLogLines)
          data["changeLogLines"].push(item.toJSON());
      }
      data["releaseImmediately"] = this.releaseImmediately;
      return data;
    }
  }

  export interface IAddVersionDto {
    version: string;
    name?: string | undefined;
    changeLogLines: AddOrUpdateChangeLogLineDto[];
    releaseImmediately?: boolean;
  }

  export class ApiInfo implements IApiInfo {
    name?: string | undefined;
    version?: string | undefined;
    environment?: string | undefined;

    constructor(data?: IApiInfo) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ApiInfo {
      data = typeof data === 'object' ? data : {};
      let result = new ApiInfo();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.name = _data["name"];
        this.version = _data["version"];
        this.environment = _data["environment"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["name"] = this.name;
      data["version"] = this.version;
      data["environment"] = this.environment;
      return data;
    }
  }

  export interface IApiInfo {
    name?: string | undefined;
    version?: string | undefined;
    environment?: string | undefined;
  }

  export class ChangeLogLineDto implements IChangeLogLineDto {
    id?: string;
    text?: string | undefined;
    labels?: string[] | undefined;
    issues?: string[] | undefined;
    createdAt?: Date;

    constructor(data?: IChangeLogLineDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ChangeLogLineDto {
      data = typeof data === 'object' ? data : {};
      let result = new ChangeLogLineDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.text = _data["text"];
        if (Array.isArray(_data["labels"])) {
          this.labels = [] as any;
          for (let item of _data["labels"])
            this.labels!.push(item);
        }
        if (Array.isArray(_data["issues"])) {
          this.issues = [] as any;
          for (let item of _data["issues"])
            this.issues!.push(item);
        }
        this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["text"] = this.text;
      if (Array.isArray(this.labels)) {
        data["labels"] = [];
        for (let item of this.labels)
          data["labels"].push(item);
      }
      if (Array.isArray(this.issues)) {
        data["issues"] = [];
        for (let item of this.issues)
          data["issues"].push(item);
      }
      data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
      return data;
    }
  }

  export interface IChangeLogLineDto {
    id?: string;
    text?: string | undefined;
    labels?: string[] | undefined;
    issues?: string[] | undefined;
    createdAt?: Date;
  }

  export class ErrorMessage implements IErrorMessage {
    message?: string | undefined;
    property?: string | undefined;

    constructor(data?: IErrorMessage) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ErrorMessage {
      data = typeof data === 'object' ? data : {};
      let result = new ErrorMessage();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.message = _data["message"];
        this.property = _data["property"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["message"] = this.message;
      data["property"] = this.property;
      return data;
    }
  }

  export interface IErrorMessage {
    message?: string | undefined;
    property?: string | undefined;
  }

  export class ErrorResponse implements IErrorResponse {
    readonly errors?: ErrorMessage[] | undefined;
    resourceIds?: { [key: string]: string; } | undefined;

    constructor(data?: IErrorResponse) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ErrorResponse {
      data = typeof data === 'object' ? data : {};
      let result = new ErrorResponse();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        if (Array.isArray(_data["errors"])) {
          (<any>this).errors = [] as any;
          for (let item of _data["errors"])
            (<any>this).errors!.push(ErrorMessage.fromJS(item));
        }
        if (_data["resourceIds"]) {
          this.resourceIds = {} as any;
          for (let key in _data["resourceIds"]) {
            if (_data["resourceIds"].hasOwnProperty(key))
              (<any>this.resourceIds)![key] = _data["resourceIds"][key];
          }
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      if (Array.isArray(this.errors)) {
        data["errors"] = [];
        for (let item of this.errors)
          data["errors"].push(item.toJSON());
      }
      if (this.resourceIds) {
        data["resourceIds"] = {};
        for (let key in this.resourceIds) {
          if (this.resourceIds.hasOwnProperty(key))
            (<any>data["resourceIds"])[key] = this.resourceIds[key];
        }
      }
      return data;
    }
  }

  export interface IErrorResponse {
    errors?: ErrorMessage[] | undefined;
    resourceIds?: { [key: string]: string; } | undefined;
  }

  export class MoveChangeLogLineDto implements IMoveChangeLogLineDto {
    targetVersionId!: string;

    constructor(data?: IMoveChangeLogLineDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): MoveChangeLogLineDto {
      data = typeof data === 'object' ? data : {};
      let result = new MoveChangeLogLineDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.targetVersionId = _data["targetVersionId"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["targetVersionId"] = this.targetVersionId;
      return data;
    }
  }

  export interface IMoveChangeLogLineDto {
    targetVersionId: string;
  }

  export class PatchChangeLogLineDto implements IPatchChangeLogLineDto {
    text?: string | undefined;
    labels?: string[] | undefined;
    issues?: string[] | undefined;

    constructor(data?: IPatchChangeLogLineDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): PatchChangeLogLineDto {
      data = typeof data === 'object' ? data : {};
      let result = new PatchChangeLogLineDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.text = _data["text"];
        if (Array.isArray(_data["labels"])) {
          this.labels = [] as any;
          for (let item of _data["labels"])
            this.labels!.push(item);
        }
        if (Array.isArray(_data["issues"])) {
          this.issues = [] as any;
          for (let item of _data["issues"])
            this.issues!.push(item);
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["text"] = this.text;
      if (Array.isArray(this.labels)) {
        data["labels"] = [];
        for (let item of this.labels)
          data["labels"].push(item);
      }
      if (Array.isArray(this.issues)) {
        data["issues"] = [];
        for (let item of this.issues)
          data["issues"].push(item);
      }
      return data;
    }
  }

  export interface IPatchChangeLogLineDto {
    text?: string | undefined;
    labels?: string[] | undefined;
    issues?: string[] | undefined;
  }

  export class PendingChangeLogLineDto implements IPendingChangeLogLineDto {
    productId?: string;
    productName?: string | undefined;
    accountId?: string;
    changeLogLine?: ChangeLogLineDto;

    constructor(data?: IPendingChangeLogLineDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): PendingChangeLogLineDto {
      data = typeof data === 'object' ? data : {};
      let result = new PendingChangeLogLineDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.productId = _data["productId"];
        this.productName = _data["productName"];
        this.accountId = _data["accountId"];
        this.changeLogLine = _data["changeLogLine"] ? ChangeLogLineDto.fromJS(_data["changeLogLine"]) : <any>undefined;
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["productId"] = this.productId;
      data["productName"] = this.productName;
      data["accountId"] = this.accountId;
      data["changeLogLine"] = this.changeLogLine ? this.changeLogLine.toJSON() : <any>undefined;
      return data;
    }
  }

  export interface IPendingChangeLogLineDto {
    productId?: string;
    productName?: string | undefined;
    accountId?: string;
    changeLogLine?: ChangeLogLineDto;
  }

  export class ProductDto implements IProductDto {
    id?: string;
    accountId?: string;
    accountName?: string | undefined;
    name?: string | undefined;
    versioningSchemeId?: string;
    versioningScheme?: string | undefined;
    languageCode?: string | undefined;
    createdByUser?: string | undefined;
    createdAt?: Date;
    isClosed?: boolean;

    constructor(data?: IProductDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): ProductDto {
      data = typeof data === 'object' ? data : {};
      let result = new ProductDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.accountId = _data["accountId"];
        this.accountName = _data["accountName"];
        this.name = _data["name"];
        this.versioningSchemeId = _data["versioningSchemeId"];
        this.versioningScheme = _data["versioningScheme"];
        this.languageCode = _data["languageCode"];
        this.createdByUser = _data["createdByUser"];
        this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        this.isClosed = _data["isClosed"];
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["accountId"] = this.accountId;
      data["accountName"] = this.accountName;
      data["name"] = this.name;
      data["versioningSchemeId"] = this.versioningSchemeId;
      data["versioningScheme"] = this.versioningScheme;
      data["languageCode"] = this.languageCode;
      data["createdByUser"] = this.createdByUser;
      data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
      data["isClosed"] = this.isClosed;
      return data;
    }
  }

  export interface IProductDto {
    id?: string;
    accountId?: string;
    accountName?: string | undefined;
    name?: string | undefined;
    versioningSchemeId?: string;
    versioningScheme?: string | undefined;
    languageCode?: string | undefined;
    createdByUser?: string | undefined;
    createdAt?: Date;
    isClosed?: boolean;
  }

  export class RoleDto implements IRoleDto {
    name?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: IRoleDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): RoleDto {
      data = typeof data === 'object' ? data : {};
      let result = new RoleDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.name = _data["name"];
        if (Array.isArray(_data["permissions"])) {
          this.permissions = [] as any;
          for (let item of _data["permissions"])
            this.permissions!.push(item);
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["name"] = this.name;
      if (Array.isArray(this.permissions)) {
        data["permissions"] = [];
        for (let item of this.permissions)
          data["permissions"].push(item);
      }
      return data;
    }
  }

  export interface IRoleDto {
    name?: string | undefined;
    permissions?: string[] | undefined;
  }

  export class SuccessResponse implements ISuccessResponse {
    message?: string | undefined;
    resourceIds?: { [key: string]: string; } | undefined;

    constructor(data?: ISuccessResponse) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): SuccessResponse {
      data = typeof data === 'object' ? data : {};
      let result = new SuccessResponse();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.message = _data["message"];
        if (_data["resourceIds"]) {
          this.resourceIds = {} as any;
          for (let key in _data["resourceIds"]) {
            if (_data["resourceIds"].hasOwnProperty(key))
              (<any>this.resourceIds)![key] = _data["resourceIds"][key];
          }
        }
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["message"] = this.message;
      if (this.resourceIds) {
        data["resourceIds"] = {};
        for (let key in this.resourceIds) {
          if (this.resourceIds.hasOwnProperty(key))
            (<any>data["resourceIds"])[key] = this.resourceIds[key];
        }
      }
      return data;
    }
  }

  export interface ISuccessResponse {
    message?: string | undefined;
    resourceIds?: { [key: string]: string; } | undefined;
  }

  export class UserDto implements IUserDto {
    id?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    timeZone?: string | undefined;
    culture?: string | undefined;
    createdAt?: Date;

    constructor(data?: IUserDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): UserDto {
      data = typeof data === 'object' ? data : {};
      let result = new UserDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.email = _data["email"];
        this.firstName = _data["firstName"];
        this.lastName = _data["lastName"];
        this.timeZone = _data["timeZone"];
        this.culture = _data["culture"];
        this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["email"] = this.email;
      data["firstName"] = this.firstName;
      data["lastName"] = this.lastName;
      data["timeZone"] = this.timeZone;
      data["culture"] = this.culture;
      data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
      return data;
    }
  }

  export interface IUserDto {
    id?: string;
    email?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    timeZone?: string | undefined;
    culture?: string | undefined;
    createdAt?: Date;
  }

  export class VersionDto implements IVersionDto {
    id?: string;
    version?: string | undefined;
    name?: string | undefined;
    productId?: string;
    productName?: string | undefined;
    accountId?: string;
    changeLogLines?: ChangeLogLineDto[] | undefined;
    createdAt?: Date;
    releasedAt?: Date | undefined;
    deletedAt?: Date | undefined;

    constructor(data?: IVersionDto) {
      if (data) {
        for (var property in data) {
          if (data.hasOwnProperty(property))
            (<any>this)[property] = (<any>data)[property];
        }
      }
    }

    static fromJS(data: any): VersionDto {
      data = typeof data === 'object' ? data : {};
      let result = new VersionDto();
      result.init(data);
      return result;
    }

    init(_data?: any) {
      if (_data) {
        this.id = _data["id"];
        this.version = _data["version"];
        this.name = _data["name"];
        this.productId = _data["productId"];
        this.productName = _data["productName"];
        this.accountId = _data["accountId"];
        if (Array.isArray(_data["changeLogLines"])) {
          this.changeLogLines = [] as any;
          for (let item of _data["changeLogLines"])
            this.changeLogLines!.push(ChangeLogLineDto.fromJS(item));
        }
        this.createdAt = _data["createdAt"] ? new Date(_data["createdAt"].toString()) : <any>undefined;
        this.releasedAt = _data["releasedAt"] ? new Date(_data["releasedAt"].toString()) : <any>undefined;
        this.deletedAt = _data["deletedAt"] ? new Date(_data["deletedAt"].toString()) : <any>undefined;
      }
    }

    toJSON(data?: any) {
      data = typeof data === 'object' ? data : {};
      data["id"] = this.id;
      data["version"] = this.version;
      data["name"] = this.name;
      data["productId"] = this.productId;
      data["productName"] = this.productName;
      data["accountId"] = this.accountId;
      if (Array.isArray(this.changeLogLines)) {
        data["changeLogLines"] = [];
        for (let item of this.changeLogLines)
          data["changeLogLines"].push(item.toJSON());
      }
      data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
      data["releasedAt"] = this.releasedAt ? this.releasedAt.toISOString() : <any>undefined;
      data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
      return data;
    }
  }

  export interface IVersionDto {
    id?: string;
    version?: string | undefined;
    name?: string | undefined;
    productId?: string;
    productName?: string | undefined;
    accountId?: string;
    changeLogLines?: ChangeLogLineDto[] | undefined;
    createdAt?: Date;
    releasedAt?: Date | undefined;
    deletedAt?: Date | undefined;
  }

  export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;
    protected isSwaggerException = true;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
      super();

      this.message = message;
      this.status = status;
      this.response = response;
      this.headers = headers;
      this.result = result;
    }

    static isSwaggerException(obj: any): obj is SwaggerException {
      return obj.isSwaggerException === true;
    }
  }

  function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new SwaggerException(message, status, response, headers, result));
  }

  function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
      if (!blob) {
        observer.next("");
        observer.complete();
      } else {
        let reader = new FileReader();
        reader.onload = event => {
          observer.next((event.target as any).result);
          observer.complete();
        };
        reader.readAsText(blob);
      }
    });
  }

}
